<!DOCTYPE html><html><head>
    <title>The LCD Toy Universe</title>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=egde,chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta value="2016-09-27T10:14:45-04:00" name="created"/></head>
<body>
  <canvas width=640 height=480 id="canvas"></canvas>
  <div id=entropy></div>
  <canvas width=500 height=100 id="plot"></canvas>
   <script type="text/javascript" charset="utf-8">
     (function () {
       var MAX_X  = 5;
       var MAX_Y  = 4;
       var CELL_SIZE = 40;
       var WIDTH  = MAX_X * CELL_SIZE; // px
       var HEIGHT = MAX_Y * CELL_SIZE; // px
       var MARGIN = 5;   // px
       var DX     = WIDTH/MAX_X - 2*MARGIN;
       var DY     = HEIGHT/MAX_Y - 2*MARGIN;
       var ele = document.getElementById("entropy");

       // Each atom the LCD universe is a segment between two adjacent
       // points, so the representation of an atom will be the x,y coordinates
       // of one end (the head), and then a value that encodes the directions from that
       // end to the other end (the tail). I.e.
       //
       //   var atom = {
       //    x: 1,
       //    y: 2,
       //    d: 0,
       //   }
       //
       // Where d encodes the direction via DIR.

       // DIR is the encoding of the four possible directions
       // an atom may face. The 't' value is the index of the
       // opposite direction, used in 'transpose'.
       var DIR = {
         0: { x:  0, y:  1, t: 1},
         1: { x:  0, y: -1, t: 0},
         2: { x:  1, y:  0, t: 3},
         3: { x: -1, y:  0, t: 2},
       };

       // Give each position in the universe a unique id, unique
       // up to transposition.
       function atomId(atom) {
         return "" + Math.floor(2 * (atom.x + DIR[atom.d].x/2))+ "," + Math.floor(2 * (atom.y + DIR[atom.d].y/2));
       }

       // The initial positions of the atoms, forming the Central Galaxy, i.e
       // the 7-segment display.
       var initial = [
         {x: 2, y: 1, d: 2},
         {x: 2, y: 3, d: 2},

         {x: 2, y: 2, d: 2},
         {x: 2, y: 2, d: 0},
         {x: 2, y: 2, d: 1},

         {x: 3, y: 2, d: 0},
         {x: 3, y: 2, d: 1},
       ];

       // LCD records the ids of all the positions in the Central Galaxy.
       var LCD = [];
       initial.forEach(function(atom) {
         LCD.push(atomId(atom));
       });

       var canvas = document.getElementById("canvas");
       canvas.width  = WIDTH;
       canvas.height = HEIGHT;
       var ctx = canvas.getContext("2d");

       // An atom is the same if you switch the head and the tail.
       // This function switches the head and tail. Used in randMove.
       function transpose(atom) {
         return {
           x: atom.x + DIR[atom.d].x,
           y: atom.y + DIR[atom.d].y,
           d: DIR[atom.d].t,
         }
       }

       function head(atom) {
         return {
           x: atom.x,
           y: atom.y,
         }
       }

       function tail(atom) {
         return {
           x: atom.x + DIR[atom.d].x,
           y: atom.y + DIR[atom.d].y,
         }
       }

       function isValid(atom) {
         var t = tail(atom);
         return (t.x >= 0) && (t.x <= MAX_X) && (t.y >= 0) && (t.y <= MAX_Y);
       }

       function drawGrid() {
         ctx.clearRect(0, 0, WIDTH, HEIGHT);
         ctx.strokeStyle = "lightgray";
         ctx.lineWidth = 1;
         for (var x = 0; x <= MAX_X ; x++) {
           ctx.beginPath();
           ctx.moveTo(MARGIN + x*DX, MARGIN);
           ctx.lineTo(MARGIN + x*DX, MARGIN + MAX_Y * DY);
           ctx.stroke();
         }
         for (var y = 0; y <= MAX_Y; y++) {
           ctx.beginPath();
           ctx.moveTo(MARGIN            , MARGIN + y*DY);
           ctx.lineTo(MARGIN +MAX_X * DX, MARGIN + y*DY);
           ctx.stroke();
         }
       }

       function drawAtom(atom) {
         ctx.strokeStyle = "red";
         ctx.lineWidth = 3;
         ctx.beginPath();
         var h = head(atom);
         var t = tail(atom);
         ctx.moveTo(MARGIN + h.x*DX, MARGIN + h.y*DY);
         ctx.lineTo(MARGIN + t.x*DX, MARGIN + t.y*DY);
         ctx.stroke();
       }

       // Move the atom to a new random position according to the rules.
       function randMove(atom) {
         // Randomly swap head and tail, so movement isn't biased.
         if (Math.random() > 0.5) {
           atom = transpose(atom);
         }
         // Choose a direction at random until you get a valid atom, i.e.
         // one where the tail still sits in the universe.
         atom.d = Math.floor(Math.random() * 4);
         while (!isValid(atom)) {
           atom.d = Math.floor(Math.random() * 4);
         }
         // Now swap head and tail.
         atom = transpose(atom);
         // Choose a direction at random until you get a valid atom, i.e.
         // one where the tail still sits in the universe.
         atom.d = Math.floor(Math.random() * 4);
         while (!isValid(atom)) {
           atom.d = Math.floor(Math.random() * 4);
         }

         return atom;
       }

       // Does the point sit in the Central Galaxy.
       function endInCentralGalaxy(pt) {
         return pt.x >= 2 && pt.x <= 3 && pt.y >= 1 && pt.y <= 3;
       }

       function touchesCentralGalaxy(atom) {
         return endInCentralGalaxy(head(atom)) || endInCentralGalaxy(tail(atom));
       }

       function calculateEntropy() {
         var inLCD = {};
         var u = 0;
         var b = 0;
         var t = 0;
         initial.forEach(function(atom) {
           var id = atomId(atom);
           // An atom is in the Central Galaxy if its ID matches
           // an ID in LCD.
           if (LCD.indexOf(id) != -1) {
             inLCD[id] = 1;
             b += 1;
           } else if (touchesCentralGalaxy(atom)) {
             t += 1;
           }
         });
         u = initial.length - Object.keys(inLCD).length;
         var ent = ((14 + 4*u - 2*b - t)/42);
         ele.textContent = ent.toPrecision(2);
         document.dispatchEvent(new CustomEvent("entropy", {detail: ent}));
       }

       drawGrid();
       initial.forEach(function(atom){
         drawAtom(atom);
       });
       calculateEntropy();

       window.setInterval(function() {
         drawGrid();
         for (var i = 0; i < initial.length; i++) {
           initial[i] = randMove(initial[i]);
           drawAtom(initial[i]);
         }
         calculateEntropy();
       }, 1000);

     })();

     (function () {
       var samples = [];

       var canvas = document.getElementById("plot");
       var width = canvas.width;
       var ctx = canvas.getContext("2d");

       function plot() {
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         ctx.strokeStyle = "darkblue";
         ctx.lineWidth = 1;
         if (samples.length == 0) {
           return;
         }
         ctx.moveTo(0, canvas.height - samples[0]*100);

         samples.forEach(function(value, x) {
           ctx.lineTo(x, canvas.height - value*100);
         });
         ctx.stroke();
       }

       document.addEventListener("entropy", function(e) {
         samples.push(e.detail);
         plot();
       });

     })();
   </script>
</body>
</html>
