<!DOCTYPE html><html><head>
    <title>The LCD Toy Universe</title>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=egde,chrome=1"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta value="2016-09-27T10:14:45-04:00" name="created"/></head>
<body>
  <style type="text/css" media="screen">
    #plot,
    #entities {
      border-bottom: solid lightgray 1px;
      border-left: solid lightgray 1px;
      margin: 1em 0;
    }

    canvas {
      display: block;
    }
  </style>
  <canvas width=640 height=480 id="canvas"></canvas>
  <div>Entropy: <span id=entropy></span></div>
  <canvas width=200 height=100 id="plot"></canvas>
  <div>Entities: <span id=entityCount></span></div>
  <canvas width=200 height=100 id="entities"></canvas>
   <script type="text/javascript" charset="utf-8">
     (function () {
       function initPlot(canvasId, detailName, max) {
         var samples = [];

         var canvas = document.getElementById(canvasId);
         var width = canvas.width;
         var ctx = canvas.getContext("2d");

         function plot() {
           ctx.clearRect(0, 0, canvas.width, canvas.height);
           ctx.strokeStyle = "darkblue";
           ctx.lineWidth = 1;
           ctx.beginPath();
           if (samples.length == 0) {
             return;
           }
           ctx.moveTo(0, canvas.height - samples[0]*canvas.height/max);

           samples.forEach(function(value, x) {
             ctx.lineTo(x+1, canvas.height - value*canvas.height/max);
           });
           ctx.stroke();
         }

         document.addEventListener("entropy", function(e) {
           samples.push(e.detail[detailName]);
           if (samples.length > canvas.width) {
             samples = samples.slice(samples.length - canvas.width);
           }
           plot();
         });
       }

       var MAX_X  = 5;
       var MAX_Y  = 4;
       var CELL_SIZE = 40;
       var WIDTH  = MAX_X * CELL_SIZE; // px
       var HEIGHT = MAX_Y * CELL_SIZE; // px
       var MARGIN = 5;   // px
       var DX     = WIDTH/MAX_X - 2*MARGIN;
       var DY     = HEIGHT/MAX_Y - 2*MARGIN;

       // Each atom the LCD universe is a segment between two adjacent
       // points, so the representation of an atom will be the x,y coordinates
       // of one end (the head), and then a value that encodes the directions from that
       // end to the other end (the tail). I.e.
       //
       //   var atom = {
       //    x: 1,
       //    y: 2,
       //    d: 0,
       //   }
       //
       // Where d encodes the direction via DIR.

       // DIR is the encoding of the four possible directions
       // an atom may face. The 't' value is the index of the
       // opposite direction, used in 'transpose'.
       var DIR = {
         0: { x:  0, y:  1, t: 1},
         1: { x:  0, y: -1, t: 0},
         2: { x:  1, y:  0, t: 3},
         3: { x: -1, y:  0, t: 2},
       };

       initPlot("plot", "entropy", 1);
       initPlot("entities", "entities", 7);

       // Give each position in the universe a unique id, unique
       // up to transposition.
       function atomId(atom) {
         return "" + Math.floor(2 * (atom.x + DIR[atom.d].x/2))+ "," + Math.floor(2 * (atom.y + DIR[atom.d].y/2));
       }

       // The initial positions of the atoms, forming the Central Galaxy, i.e
       // the 7-segment display.
       var initial = [
         {x: 2, y: 1, d: 2},
         {x: 2, y: 3, d: 2},

         {x: 2, y: 2, d: 2},
         {x: 2, y: 2, d: 0},
         {x: 2, y: 2, d: 1},

         {x: 3, y: 2, d: 0},
         {x: 3, y: 2, d: 1},
       ];

       // LCD records the ids of all the positions in the Central Galaxy.
       var LCD = [];
       initial.forEach(function(atom) {
         LCD.push(atomId(atom));
       });

       var canvas = document.getElementById("canvas");
       canvas.width  = WIDTH;
       canvas.height = HEIGHT;
       var ctx = canvas.getContext("2d");

       // An atom is the same if you switch the head and the tail.
       // This function switches the head and tail. Used in randMove.
       function transpose(atom) {
         return {
           x: atom.x + DIR[atom.d].x,
           y: atom.y + DIR[atom.d].y,
           d: DIR[atom.d].t,
         }
       }

       function head(atom) {
         return {
           x: atom.x,
           y: atom.y,
         }
       }

       function tail(atom) {
         return {
           x: atom.x + DIR[atom.d].x,
           y: atom.y + DIR[atom.d].y,
         }
       }

       function isValid(atom) {
         var t = tail(atom);
         return (t.x >= 0) && (t.x <= MAX_X) && (t.y >= 0) && (t.y <= MAX_Y);
       }

       function drawGrid() {
         ctx.clearRect(0, 0, WIDTH, HEIGHT);
         ctx.strokeStyle = "lightgray";
         ctx.lineWidth = 1;
         for (var x = 0; x <= MAX_X ; x++) {
           ctx.beginPath();
           ctx.moveTo(MARGIN + x*DX, MARGIN);
           ctx.lineTo(MARGIN + x*DX, MARGIN + MAX_Y * DY);
           ctx.stroke();
         }
         for (var y = 0; y <= MAX_Y; y++) {
           ctx.beginPath();
           ctx.moveTo(MARGIN            , MARGIN + y*DY);
           ctx.lineTo(MARGIN +MAX_X * DX, MARGIN + y*DY);
           ctx.stroke();
         }
       }

       function drawAtom(atom) {
         ctx.strokeStyle = "red";
         ctx.lineWidth = 3;
         ctx.beginPath();
         var h = head(atom);
         var t = tail(atom);
         ctx.moveTo(MARGIN + h.x*DX, MARGIN + h.y*DY);
         ctx.lineTo(MARGIN + t.x*DX, MARGIN + t.y*DY);
         ctx.stroke();
       }

       // Move the atom to a new random position according to the rules.
       function randMove(atom) {
         // Randomly swap head and tail, so movement isn't biased.
         if (Math.random() > 0.5) {
           atom = transpose(atom);
         }
         // Choose a direction at random until you get a valid atom, i.e.
         // one where the tail still sits in the universe.
         atom.d = Math.floor(Math.random() * 4);
         while (!isValid(atom)) {
           atom.d = Math.floor(Math.random() * 4);
         }
         // Now swap head and tail.
         atom = transpose(atom);
         // Choose a direction at random until you get a valid atom, i.e.
         // one where the tail still sits in the universe.
         atom.d = Math.floor(Math.random() * 4);
         while (!isValid(atom)) {
           atom.d = Math.floor(Math.random() * 4);
         }

         return atom;
       }

       // Does the point sit in the Central Galaxy.
       function endInCentralGalaxy(pt) {
         return pt.x >= 2 && pt.x <= 3 && pt.y >= 1 && pt.y <= 3;
       }

       function touchesCentralGalaxy(atom) {
         return endInCentralGalaxy(head(atom)) || endInCentralGalaxy(tail(atom));
       }

       function ptEqual(a, b) {
         return a.x == b.x && a.y == b.y;
       }

       function atomsTouch(a, b) {
         return ptEqual(head(a), head(b)) ||
                ptEqual(head(a), tail(b)) ||
                ptEqual(tail(a), head(b)) ||
                ptEqual(tail(a), tail(b));
       }

       function atomInEntity(atom, entity) {
         for (var i = 0; i < entity.length; i++) {
           if (atomsTouch(atom, entity[i])) {
             return true;
           }
         }
         return false;
       }

       function calculateEntropy() {
         var inLCD = {};
         var u = 0;
         var b = 0;
         var t = 0;
         initial.forEach(function(atom) {
           var id = atomId(atom);
           // An atom is in the Central Galaxy if its ID matches
           // an ID in LCD.
           if (LCD.indexOf(id) != -1) {
             inLCD[id] = 1;
             b += 1;
           } else if (touchesCentralGalaxy(atom)) {
             t += 1;
           }
         });
         u = initial.length - Object.keys(inLCD).length;
         var ent = ((14 + 4*u - 2*b - t)/42);

         // Now calulate the number of distinct entities.
         var entities = [];
         var atoms = initial.slice();
         while (atoms.length > 0) {
           var entity = [atoms.pop()];
           var added = true;
           while (added) {
             added = false;
             for (var i = 0; i < atoms.length; i++) {
               if (atomInEntity(atoms[i], entity)) {
                 added = true;
                 entity.push(atoms[i]);
                 atoms.splice(i, 1);
                 break;
               }
             }
           }
           entities.push(entity);
         }

         document.getElementById("entropy").textContent = ent.toPrecision(2);
         document.getElementById("entityCount").textContent = entities.length;
         document.dispatchEvent(new CustomEvent("entropy", {detail: {
           entropy: ent,
           entities: entities.length,
         }}));
       }

       drawGrid();
       initial.forEach(function(atom){
         drawAtom(atom);
       });
       calculateEntropy();

       window.setInterval(function() {
         drawGrid();
         for (var i = 0; i < initial.length; i++) {
           initial[i] = randMove(initial[i]);
           drawAtom(initial[i]);
         }
         calculateEntropy();
       }, 100);

     })();

   </script>
</body>
</html>
