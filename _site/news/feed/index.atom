<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="https://bitworking.org/news/feed/index.atom" rel="self" type="application/atom+xml" /><link href="https://bitworking.org/" rel="alternate" type="text/html" /><updated>2017-08-07T04:06:48-04:00</updated><id>https://bitworking.org/</id><title type="html">BitWorking</title><subtitle>Joe Gregorio - REST, Web, Python, Go, APIs, Dad, Husband, Maker, or any linear combination of such. Googler.
</subtitle><entry><title type="html">L-Systems with Redux and StateReflector</title><link href="https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector" rel="alternate" type="text/html" title="L-Systems with Redux and StateReflector" /><published>2017-08-06T00:00:00-04:00</published><updated>2017-08-06T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector</id><content type="html" xml:base="https://bitworking.org/news/2017/08/l-systems-with-redux-and-statereflector">&lt;p&gt;
  This is &lt;a
    href=&quot;/news/2017/08/d3-and-l-systems-with-redux-and-statereflector/news/2017/07/d3-and-l-systems-with-live-controls-and-redux&quot;&gt;D3
    and L-Systems with Redux and StateReflector&lt;/a&gt;, but now w/o the D3.js.
&lt;/p&gt;

&lt;p&gt;
  While &lt;a href=&quot;https://d3js.org/&quot;&gt;D3.js&lt;/a&gt; is fun, at this point it is a
  bit distracting, I'm more interested in Redux and data binding, so time to
  move back to just drawing static images on canvas.
&lt;/p&gt;

&lt;label for=length&gt;Length:&lt;/label&gt;
&lt;input type=range name=length id=length min=1 max=10 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=lengthDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;label for=angle&gt;Angle:&lt;/label&gt;
&lt;input type=range name=angle id=angle min=0.01 max=1 step=0.01 /&gt;
&lt;span style=&quot;padding: 0 10px;&quot; id=angleDisplay&gt;&lt;/span&gt;
&lt;br&gt;
&lt;canvas width=600 height=600&gt;&lt;/canvas&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
this.StateReflector = this.StateReflector || {};

(function(sr) {
  &quot;use strict&quot;;

  // A Promise that resolves when DOMContentLoaded has fired.
  sr.DomReady = new Promise(function(resolve, reject) {
    if (document.readyState != 'loading') {
      // If readyState is already past loading then
      // DOMContentLoaded has already fired, so just resolve.
      resolve();
    } else {
      document.addEventListener('DOMContentLoaded', resolve);
    }
  });

  // Namespace for utilities for working with URL query strings.
  sr.query = {};

  // fromObject takes an object and encodes it into a query string.
  //
  // The reverse of this function is toObject.
  sr.query.fromObject = function(o) {
    var ret = [];
    Object.keys(o).sort().forEach(function(key) {
      if (Array.isArray(o[key])) {
        o[key].forEach(function(value) {
          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        })
      } else if (typeof(o[key]) == 'object') {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(sr.query.fromObject(o[key])));
      } else {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(o[key]));
      }
    });
    return ret.join('&amp;');
  }


  // toObject decodes a query string into an object
  // using the 'target' as a source for hinting on the types
  // of the values.
  //
  //   &quot;a=2&amp;b=true&quot;
  //
  // decodes to:
  //
  //   {
  //     a: 2,
  //     b: true,
  //   }
  //
  // When given a target of:
  //
  //   {
  //     a: 1.0,
  //     b: false,
  //   }
  //
  // Note that a target of {} would decode
  // the same query string into:
  //
  //   {
  //     a: &quot;2&quot;,
  //     b: &quot;true&quot;,
  //   }
  //
  // Only Number, String, Boolean, Object, and Array of String hints are supported.
  sr.query.toObject = function(s, target) {
    var target = target || {};
    var ret = {};
    var vars = s.split(&quot;&amp;&quot;);
    for (var i=0; i&lt;vars.length; i++) {
      var pair = vars[i].split(&quot;=&quot;, 2);
      if (pair.length == 2) {
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        if (target.hasOwnProperty(key)) {
          switch (typeof(target[key])) {
            case 'boolean':
              ret[key] = value==&quot;true&quot;;
              break;
            case 'number':
              ret[key] = Number(value);
              break;
            case 'object': // Arrays report as 'object' to typeof.
              if (Array.isArray(target[key])) {
                var r = ret[key] || [];
                r.push(value);
                ret[key] = r;
              } else {
                ret[key] = sr.query.toObject(value, target[key]);
              }
              break;
            case 'string':
              ret[key] = value;
              break;
            default:
              ret[key] = value;
          }
        } else {
          ret[key] = value;
        }
      }
    }
    return ret;
  }

  // Namespace for utilities for working with Objects.
  sr.object = {};

  // Returns true if a and b are equal, covers Boolean, Number, String and
  // Arrays and Objects.
  sr.object.equals = function(a, b) {
    if (typeof(a) != typeof(b)) {
      return false
    }
    var ta = typeof(a);
    if (ta == 'string' || ta == 'boolean' || ta == 'number') {
      return a === b
    }
    if (ta == 'object') {
      if (Array.isArray(ta)) {
        return JSON.stringify(a) == JSON.stringify(b)
      } else {
        return sr.query.fromObject(a) == sr.query.fromObject(b)
      }
    }
  }

  // Returns an object with only values that are in o that are different
  // from d.
  //
  // Only works shallowly, i.e. only diffs on the attributes of
  // o and d, and only for the types that sr.object.equals supports.
  sr.object.getDelta = function (o, d) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (!sr.object.equals(o[key], d[key])) {
        ret[key] = o[key];
      }
    });
    return ret;
  };

  // Returns a copy of object o with values from delta if they exist.
  sr.object.applyDelta = function (delta, o) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (delta.hasOwnProperty(key)) {
        ret[key] = JSON.parse(JSON.stringify(delta[key]));
      } else {
        ret[key] = JSON.parse(JSON.stringify(o[key]));
      }
    });
    return ret;
  };

  // Track the state of a page and reflect it to and from the URL.
  //
  // store - A Redux store.
  //        The state must be on Object and all the values in the Object
  //        must be Number, String, Boolean, Object, or Array of String.
  //        Doesn't handle NaN, null, or undefined.
  //
  // stateChange - A callback of the form function(state) that is called when
  //        state has been changed by a change in the URL, the return value
  //        should be appropriate for passing into store.dispatch();
  sr.stateReflector = function(store, stateChange) {
    var defaultState = store.getState();
    var lastState = store.getState();
    store.subscribe(function() {
      var state = store.getState();
      if (Object.keys(sr.object.getDelta(lastState, state)).length &gt; 0) {
        lastState = state;
        var q = sr.query.fromObject(sr.object.getDelta(state, defaultState));
        window.history.pushState(null, &quot;&quot;, window.location.origin + window.location.pathname + &quot;#&quot; +  q);
      }
    });

    // stateFromURL should be called when the URL has changed, it updates the state.
    var stateFromURL = function() {
      var delta = sr.query.toObject(window.location.hash.slice(1), defaultState);

      lastState = sr.object.applyDelta(delta, defaultState);
      store.dispatch(stateChange(lastState));
    }

    sr.DomReady.then(stateFromURL);

    // Every popstate event should also update the state.
    window.addEventListener('popstate', stateFromURL);
  }

})(this.StateReflector);
  &lt;/script&gt;

&lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
  (function () {
    var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
    var $ = (id) =&gt; document.getElementById(id);

    var canvas = document.querySelector(&quot;canvas&quot;),
      ctx = canvas.getContext(&quot;2d&quot;),
      width = canvas.width,
      height = canvas.height;

    var rules = {
      &quot;X&quot;: &quot;F-[[X]+X]+F[+FX]-X&quot;,
      &quot;F&quot;: &quot;FF&quot;,
      &quot;+&quot;: &quot;+&quot;,
      &quot;-&quot;: &quot;-&quot;,
      &quot;[&quot;: &quot;[&quot;,
      &quot;]&quot;: &quot;]&quot;,
    }
    var E = (s) =&gt; s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot;;
    var L = E(E(E(E(E(&quot;X&quot;)))));

    function draw(x, y, len, angle) {
      var p = { x: x, y: y, a: 3 };
      var stack = [];
      ctx.beginPath()
      ctx.moveTo(p.x, p.y)
      L.split(&quot;&quot;).forEach(function(ch) {
        if (ch == &quot;F&quot;) {
          p.x += len*Math.sin(p.a);
          p.y += len*Math.cos(p.a);
          ctx.lineTo(p.x, p.y);
          ctx.stroke();
        } else if (ch == &quot;-&quot;) {
          p.a += angle;
        } else if (ch == &quot;+&quot;) {
          p.a -= angle;
        } else if (ch == &quot;[&quot;) {
          stack.push(dup(p));
        } else if (ch == &quot;]&quot;) {
          p = stack.pop();
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
        }
      })
    }

    var defaultState = {
      length: 7,
      angle: 0.4,
    };

    var updateState = (state = defaultState, action) =&gt; {
      if (action.type == &quot;@@redux/INIT&quot;) {
      } else if (action.type == &quot;REPLACE_ALL&quot;) {
        state = dup(action.value);
      } else {
        state = dup(state);
        state[action.type] = action.value;
      }
      return state;
    };

    var store = Redux.createStore(updateState);

    function render() {
      var state = store.getState();
      $('length').value = state.length;
      $('angle').value = state.angle;
      $('lengthDisplay').innerText = state.length;
      $('angleDisplay').innerText = state.angle;
      ctx.clearRect(0, 0, width, height);
      draw(width/2, height, state.length, state.angle);
    }

    store.subscribe(render);

    StateReflector.stateReflector(store, function(state) {
      return {type: &quot;REPLACE_ALL&quot;, value: state};
    });

    function dispatchFromEvent(id, event, xform) {
      $(id).addEventListener(event, function(e) {
        store.dispatch({
          type: e.target.id,
          value: xform(e),
        });
      });
    }

    dispatchFromEvent('length', 'input', (e) =&gt; +e.target.value);
    dispatchFromEvent('angle', 'input', (e) =&gt; +e.target.value);
  })();
&lt;/script&gt;
&lt;script src=&quot;https://gist.github.com/jcgregorio/7d83bcd9670575ec6c1f9bd682f7b24a.js&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">This is D3 and L-Systems with Redux and StateReflector, but now w/o the D3.js.</summary></entry><entry><title type="html">D3 and L-Systems with Redux and StateReflector</title><link href="https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector" rel="alternate" type="text/html" title="D3 and L-Systems with Redux and StateReflector" /><published>2017-08-05T00:00:00-04:00</published><updated>2017-08-05T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector</id><content type="html" xml:base="https://bitworking.org/news/2017/08/d3-and-l-systems-with-redux-and-statereflector">&lt;p&gt;
  This is &lt;a href=&quot;/news/2017/07/d3-and-l-systems-with-live-controls-and-redux&quot;&gt;D3
    and L-Systems with live controls and Redux&lt;/a&gt;, but now state is reflected
  into the &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;URL
    Fragment&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
  The syncing is two way, that is, changes to the state of the controls are
  reflected into the URL Fragment, and changes to the fragment are reflected
  into the state of the controls, so every change give you a permalink to
  that state, and browser history navigation works.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
this.StateReflector = this.StateReflector || {};

(function(sr) {
  &quot;use strict&quot;;

  // A Promise that resolves when DOMContentLoaded has fired.
  sr.DomReady = new Promise(function(resolve, reject) {
    if (document.readyState != 'loading') {
      // If readyState is already past loading then
      // DOMContentLoaded has already fired, so just resolve.
      resolve();
    } else {
      document.addEventListener('DOMContentLoaded', resolve);
    }
  });

  // Namespace for utilities for working with URL query strings.
  sr.query = {};

  // fromObject takes an object and encodes it into a query string.
  //
  // The reverse of this function is toObject.
  sr.query.fromObject = function(o) {
    var ret = [];
    Object.keys(o).sort().forEach(function(key) {
      if (Array.isArray(o[key])) {
        o[key].forEach(function(value) {
          ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        })
      } else if (typeof(o[key]) == 'object') {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(sr.query.fromObject(o[key])));
      } else {
        ret.push(encodeURIComponent(key) + '=' + encodeURIComponent(o[key]));
      }
    });
    return ret.join('&amp;');
  }


  // toObject decodes a query string into an object
  // using the 'target' as a source for hinting on the types
  // of the values.
  //
  //   &quot;a=2&amp;b=true&quot;
  //
  // decodes to:
  //
  //   {
  //     a: 2,
  //     b: true,
  //   }
  //
  // When given a target of:
  //
  //   {
  //     a: 1.0,
  //     b: false,
  //   }
  //
  // Note that a target of {} would decode
  // the same query string into:
  //
  //   {
  //     a: &quot;2&quot;,
  //     b: &quot;true&quot;,
  //   }
  //
  // Only Number, String, Boolean, Object, and Array of String hints are supported.
  sr.query.toObject = function(s, target) {
    var target = target || {};
    var ret = {};
    var vars = s.split(&quot;&amp;&quot;);
    for (var i=0; i&lt;vars.length; i++) {
      var pair = vars[i].split(&quot;=&quot;, 2);
      if (pair.length == 2) {
        var key = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair[1]);
        if (target.hasOwnProperty(key)) {
          switch (typeof(target[key])) {
            case 'boolean':
              ret[key] = value==&quot;true&quot;;
              break;
            case 'number':
              ret[key] = Number(value);
              break;
            case 'object': // Arrays report as 'object' to typeof.
              if (Array.isArray(target[key])) {
                var r = ret[key] || [];
                r.push(value);
                ret[key] = r;
              } else {
                ret[key] = sr.query.toObject(value, target[key]);
              }
              break;
            case 'string':
              ret[key] = value;
              break;
            default:
              ret[key] = value;
          }
        } else {
          ret[key] = value;
        }
      }
    }
    return ret;
  }

  // Namespace for utilities for working with Objects.
  sr.object = {};

  // Returns true if a and b are equal, covers Boolean, Number, String and
  // Arrays and Objects.
  sr.object.equals = function(a, b) {
    if (typeof(a) != typeof(b)) {
      return false
    }
    var ta = typeof(a);
    if (ta == 'string' || ta == 'boolean' || ta == 'number') {
      return a === b
    }
    if (ta == 'object') {
      if (Array.isArray(ta)) {
        return JSON.stringify(a) == JSON.stringify(b)
      } else {
        return sr.query.fromObject(a) == sr.query.fromObject(b)
      }
    }
  }

  // Returns an object with only values that are in o that are different
  // from d.
  //
  // Only works shallowly, i.e. only diffs on the attributes of
  // o and d, and only for the types that sr.object.equals supports.
  sr.object.getDelta = function (o, d) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (!sr.object.equals(o[key], d[key])) {
        ret[key] = o[key];
      }
    });
    return ret;
  };

  // Returns a copy of object o with values from delta if they exist.
  sr.object.applyDelta = function (delta, o) {
    var ret = {};
    Object.keys(o).forEach(function(key) {
      if (delta.hasOwnProperty(key)) {
        ret[key] = JSON.parse(JSON.stringify(delta[key]));
      } else {
        ret[key] = JSON.parse(JSON.stringify(o[key]));
      }
    });
    return ret;
  };

  // Track the state of a page and reflect it to and from the URL.
  //
  // store - A Redux store.
  //        The state must be on Object and all the values in the Object
  //        must be Number, String, Boolean, Object, or Array of String.
  //        Doesn't handle NaN, null, or undefined.
  //
  // stateChange - A callback of the form function(state) that is called when
  //        state has been changed by a change in the URL, the return value
  //        should be appropriate for passing into store.dispatch();
  sr.stateReflector = function(store, stateChange) {
    var defaultState = store.getState();
    var lastState = store.getState();
    store.subscribe(function() {
      var state = store.getState();
      if (Object.keys(sr.object.getDelta(lastState, state)).length &gt; 0) {
        lastState = state;
        var q = sr.query.fromObject(sr.object.getDelta(state, defaultState));
        window.history.pushState(null, &quot;&quot;, window.location.origin + window.location.pathname + &quot;#&quot; +  q);
      }
    });

    // stateFromURL should be called when the URL has changed, it updates the state.
    var stateFromURL = function() {
      var delta = sr.query.toObject(window.location.hash.slice(1), defaultState);

      lastState = sr.object.applyDelta(delta, defaultState);
      store.dispatch(stateChange(lastState));
    }

    sr.DomReady.then(stateFromURL);

    // Every popstate event should also update the state.
    window.addEventListener('popstate', stateFromURL);
  }

})(this.StateReflector);
  &lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
      var $ = (id) =&gt; document.getElementById(id);

      var defaultState = {
        linkStrength: 0.5,
        linkDistance: 3,
        chargeStrength: -1,
      };

      var linkForce = d3.forceLink().iterations(5).id(function(d) { return d.id; });
      var charge = d3.forceManyBody();
      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      var updateState = (state = defaultState, action) =&gt; {
        if (action.type == &quot;@@redux/INIT&quot;) {
        } else if (action.type == &quot;REPLACE_ALL&quot;) { // This is new.
          state = dup(action.value);
        } else {
            state = dup(state);
          state[action.type] = action.value;
        }
        return state;
      }

      var store = Redux.createStore(updateState);

      function render() {
        var state = store.getState();
        $('linkStrength').value = state.linkStrength;
        $('linkDistance').value = state.linkDistance;
        $('chargeStrength').value = state.chargeStrength;
        $('linkStrengthDisplay').innerText = state.linkStrength;
        $('linkDistanceDisplay').innerText = state.linkDistance;
        $('chargeStrengthDisplay').innerText = state.chargeStrength;
        linkForce.distance(state.linkDistance).strength(state.linkStrength);
        charge.strength(state.chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      store.subscribe(render);

      // This is new.
      StateReflector.stateReflector(store, function(state) {
        return {type: &quot;REPLACE_ALL&quot;, value: state};
      });
      render();

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      function dispatchFromEvent(id, event, xform) {
        $(id).addEventListener(event, function(e) {
          store.dispatch({
            type: e.target.id,
            value: xform(e),
          });
        });
      }

      dispatchFromEvent('linkDistance', 'input', (e) =&gt; +e.target.value);
      dispatchFromEvent('linkStrength', 'input', (e) =&gt; Math.abs(+e.target.value));
      dispatchFromEvent('chargeStrength', 'input', (e) =&gt; -Math.abs(+e.target.value));

    })();
  &lt;/script&gt;

  &lt;p&gt;
    There are only two small changes from the previous code, the addition of a
    &lt;a
      href=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a#file-l-system-js-L58&quot;&gt;
      new action &quot;REPLACE_ALL&quot; that the store understands&lt;/a&gt;, and then 
    &lt;a
      href=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a#file-l-system-js-L84&quot;&gt;the call
      to initialize StateReflector&lt;/a&gt;.
  &lt;/p&gt;

  &lt;p&gt;
    The StateReflector is extraced from &lt;a
      href=&quot;https://github.com/google/skia-buildbot/blob/32ea496dbdc5865230d25073ac44f27ce16bb735/res/js/common.js#L709&quot;&gt;this
      code&lt;/a&gt; from the &lt;a href=&quot;https://skia.org&quot;&gt;Skia&lt;/a&gt; Infrastructure codebase. The URL Fragment will
    only contain information that's required, this is, if a value in the state
    is unchanged from the default or initial value, then that value won't
    appear in the URL Fragment.
  &lt;/p&gt;
  &lt;p&gt;
    The pairing with Redux makes this much nicer. In all of our (Skia Infra) current code
    we don't use Redux, and so for StateReflector to work it needs to monitor
    the internal state of the page which is does using a 100ms timer.
    While the overhead is very low, having a non-polling solution is
    obviously better.
  &lt;/p&gt;
  &lt;p&gt;
    The StateReflector code is also modified from the original so that it
    store the state in the URL Fragment, while the original code stores the
    state in the URL Query. It's probably worth making that a configuration
    option to stateReflector.
  &lt;/p&gt;
  &lt;p&gt;
    If StateReflector looks useful to anyone let me know in the comments
    and I'll stand up a repo and port the tests over too.
  &lt;/p&gt;
  &lt;script
    src=&quot;https://gist.github.com/jcgregorio/d3fae4dd7ebc3617cd669a855ae4ad9a.js&quot;&gt;&lt;/script&gt;</content><author><name></name></author><summary type="html">This is D3 and L-Systems with live controls and Redux, but now state is reflected into the URL Fragment.</summary></entry><entry><title type="html">What a bold platform really looks like.</title><link href="https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like" rel="alternate" type="text/html" title="What a bold platform really looks like." /><published>2017-07-29T00:00:00-04:00</published><updated>2017-07-29T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like</id><content type="html" xml:base="https://bitworking.org/news/2017/07/what-a-bold-platform-really-looks-like">&lt;p&gt;&lt;a href=&quot;http://www.huffingtonpost.com/entry/chuck-schumer-single-payer_us_5974b05be4b00e4363e0164e&quot;&gt;Chuck Schumer Says Senate Democrats Are Open To Single-Payer Health Care&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“We’re going to look at broader things [for health care],” he said.
“Single-payer is one of them.. Many things are on the table. Medicare for
people above 55 is on the table. A buy-in to Medicare is on the table.
Buy-in to Medicaid is on the table.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yeah, &lt;strong&gt;bold&lt;/strong&gt; leadership always comes from phrases like “on the table”. Don’t
you remember &lt;a href=&quot;http://www.telegraph.co.uk/news/winston-churchill/11366880/Winston-Churchills-10-most-important-speeches.html&quot;&gt;Churchill’s famous
speech&lt;/a&gt;?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Going to the end is on the table. Fighting in France is on the table, fighting on the
seas and oceans is a possibility, fighting with growing confidence and growing strength
in the air is something we’re certainly willing to talk about.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The leadership on display here is just pathetic.&lt;/p&gt;

&lt;p&gt;A simple bold platform is very easy to state, and also one that’s easy to
support. Additionally, if you keep it direct you can more easily construct
radical arguments to move the &lt;a href=&quot;https://en.wikipedia.org/wiki/Overton_window&quot;&gt;Overton&lt;/a&gt; window.
For example, on just three issues, the platform could be boldly and simply
stated, and the Overton postions below are the ones you get some people to
state, so that the platform position looks like a reasonable compromise.&lt;/p&gt;

&lt;h2 id=&quot;healthcare&quot;&gt;Healthcare&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Medicare for all.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: Let’s nationalize hospitals and shut down the health insurance industry.&lt;/p&gt;

&lt;h2 id=&quot;education&quot;&gt;Education&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Free college education (up to a bachelor’s degree).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: Let’s nationalize the education system and extend mandatory education from a high school diploma to a bachelor’s degree.&lt;/p&gt;

&lt;h2 id=&quot;taxes&quot;&gt;Taxes&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Platform&lt;/strong&gt;: Return to a progressive tax system where the wealthy pay their
fair share and loopholes are closed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Overton&lt;/strong&gt;: A top marginal income tax rate of 90%.&lt;/p&gt;

&lt;p&gt;Now aren’t those a lot more appealing than the mealy mouthed alternatives?&lt;/p&gt;</content><author><name></name></author><summary type="html">Chuck Schumer Says Senate Democrats Are Open To Single-Payer Health Care</summary></entry><entry><title type="html">D3 and L-Systems with live controls and Redux</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux" rel="alternate" type="text/html" title="D3 and L-Systems with live controls and Redux" /><published>2017-07-23T00:00:00-04:00</published><updated>2017-07-23T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls-and-redux">&lt;p&gt;
  This is just &lt;a href=&quot;/news/2017/07/d3-and-l-systems-with-live-controls&quot;&gt;D3
    and L-Systems with live controls&lt;/a&gt;, but now state is managed by &lt;a
    href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;. Oh, and also arrow functions,
  because &lt;a href=&quot;https://caniuse.com/#feat=arrow-functions&quot;&gt;they're
    available everywhere I care about&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
  I've been reading about Redux and wanted to try it out. It seems
  nice, as it forced me to consolidate everything about page state, which
  caused me to clean up the code quite a bit. I like that in a tool. It's
  also the reason I like Go and way it handles 'error', it forces me to think
  about the not-happy-path as opposed to the happy-path, which always makes
  my code better.
&lt;/p&gt;
&lt;p&gt;
  I think it's interesting that there isn't a library to map the state into
  the URL, at least I couldn't find anything that wasn't either a React based
  solution or a full blown routing package. I've got some &lt;a
    href=&quot;https://github.com/google/skia-buildbot/blob/32ea496dbdc5865230d25073ac44f27ce16bb735/res/js/common.js#L720&quot;&gt;code that already
    does that&lt;/a&gt;, I wonder if it would be useful to break that out as its own
  library.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var dup = (o) =&gt; JSON.parse(JSON.stringify(o));
      var $ = (id) =&gt; document.getElementById(id);

      var defaultState = {
        linkStrength: 0.5,
        linkDistance: 3,
        chargeStrength: -1,
      };

      var linkForce = d3.forceLink().iterations(5).id(function(d) { return d.id; });
      var charge = d3.forceManyBody();
      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      var updateState = (state = defaultState, action) =&gt; {
        state = dup(state);
        state[action.type] = action.value;
        return state;
      }

      var store = Redux.createStore(updateState);

      function render() {
        var state = store.getState();
        $('linkStrength').value = state.linkStrength;
        $('linkDistance').value = state.linkDistance;
        $('chargeStrength').value = state.chargeStrength;
        $('linkStrengthDisplay').innerText = state.linkStrength;
        $('linkDistanceDisplay').innerText = state.linkDistance;
        $('chargeStrengthDisplay').innerText = state.chargeStrength;
        linkForce.distance(state.linkDistance).strength(state.linkStrength);
        charge.strength(state.chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      store.subscribe(render);
      render();

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      function dispatchFromEvent(id, event, xform) {
        $(id).addEventListener(event, function(e) {
          store.dispatch({
            type: e.target.id,
            value: xform(e),
          });
        });
      }

      dispatchFromEvent('linkDistance', 'input', (e) =&gt; +e.target.value);
      dispatchFromEvent('linkStrength', 'input', (e) =&gt; Math.abs(+e.target.value));
      dispatchFromEvent('chargeStrength', 'input', (e) =&gt; -Math.abs(+e.target.value));

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">This is just D3 and L-Systems with live controls, but now state is managed by Redux. Oh, and also arrow functions, because they're available everywhere I care about.</summary></entry><entry><title type="html">D3 and L-Systems with live controls</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls" rel="alternate" type="text/html" title="D3 and L-Systems with live controls" /><published>2017-07-22T00:00:00-04:00</published><updated>2017-07-22T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems-with-live-controls">&lt;p&gt;
  An &lt;a href=&quot;/news/2017/07/d3-and-l-systems&quot;&gt;L-System fed into d3-force&lt;/a&gt;, but now with controls that allow you to
  change some of the simulation parameters.
&lt;/p&gt;

  &lt;label for=&quot;linkDistance&quot;&gt;Link Distance:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkDistance&quot; id=&quot;linkDistance&quot; min=1 max=10 value=&quot;3&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkDistanceDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;linkStrength&quot;&gt;Link Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;linkStrength&quot; id=&quot;linkStrength&quot; value=&quot;0.5&quot; min=0.01 max=4 step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=linkStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;label for=&quot;chargeStrength&quot;&gt;Charge Strength:&lt;/label&gt;
  &lt;input type=&quot;range&quot; name=&quot;chargeStrength&quot; id=&quot;chargeStrength&quot; value=&quot;-1&quot; min=&quot;-10&quot; max=&quot;-0.01&quot; step=&quot;0.01&quot; /&gt;
  &lt;span style=&quot;padding: 0 10px;&quot; id=chargeStrengthDisplay&gt;&lt;/span&gt;
  &lt;br&gt;
  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var linkDistance = 3;
      var linkStrength = 0.5;
      var linkForce = d3.forceLink().distance(linkDistance).strength(linkStrength).iterations(5).id(function(d) { return d.id; });
      var chargeStrength = -1;
      var charge = d3.forceManyBody().strength(chargeStrength);
      simulation = d3.forceSimulation()
          .force(&quot;link&quot;, linkForce)
          .force(&quot;charge&quot;, charge)
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2))

      function updateSimulation() {
        linkForce.distance(linkDistance).strength(linkStrength);
        charge.strength(chargeStrength);
        simulation.alphaTarget(0.1).restart();
      }

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

      document.getElementById('linkDistance').addEventListener('input', function(e) {
        linkDistance = +e.target.value;
        document.getElementById('linkDistanceDisplay').innerText = linkDistance;
        updateSimulation();
      });

      document.getElementById('linkStrength').addEventListener('input', function(e) {
        linkStrength = +e.target.value;
        if (linkStrength &lt; 0) {
          linkStrength = -linkStrength;
          e.target.value = linkStrength;
        }
        document.getElementById('linkStrengthDisplay').innerText = linkStrength;
        updateSimulation();
      });

      document.getElementById('chargeStrength').addEventListener('input', function(e) {
        chargeStrength = +e.target.value;
        if (chargeStrength &gt; 0) {
          chargeStrength = -chargeStrength;
          e.target.value = chargeStrength;
        }
        document.getElementById('chargeStrengthDisplay').innerText = chargeStrength;
        updateSimulation();
      });

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">An L-System fed into d3-force, but now with controls that allow you to change some of the simulation parameters.</summary></entry><entry><title type="html">D3 and L-Systems</title><link href="https://bitworking.org/news/2017/07/d3-and-l-systems" rel="alternate" type="text/html" title="D3 and L-Systems" /><published>2017-07-20T00:00:00-04:00</published><updated>2017-07-20T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/d3-and-l-systems</id><content type="html" xml:base="https://bitworking.org/news/2017/07/d3-and-l-systems">&lt;p&gt;
  So we know &lt;a
    href=&quot;https://bitworking.org/news/2017/07/l-systems&quot;&gt;L-Systems&lt;/a&gt; are
  fun. What if we let &lt;a href=&quot;https://github.com/d3/d3-force&quot;&gt;d3-force&lt;/a&gt;
  layout the nodes of the L-System?
&lt;/p&gt;

  &lt;canvas width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;
  &lt;script src=&quot;https://d3js.org/d3.v4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      var start = {id: &quot;0&quot;};
      var graph = {
        &quot;nodes&quot;: [start],
        &quot;links&quot;: [],
      };
      var n = 0;
      var st = [start];
      L = E(E(E(E(E(&quot;X&quot;))))).split('').forEach(function(ch) {
        if (ch == &quot;[&quot;) {
          n += 1;
          var node = {id: &quot;&quot;+n};
          st.push(node);
          graph.nodes.push(node);
          graph.links.push(
            {
              source: st[st.length-1].id,
              target: st[st.length-2].id,
            },
          );
        } else if (ch == &quot;]&quot;) {
          st.pop()
        }
      });

      var canvas = document.querySelector(&quot;canvas&quot;),
            context = canvas.getContext(&quot;2d&quot;),
            width = canvas.width,
            height = canvas.height;

      var simulation = d3.forceSimulation()
          .force(&quot;link&quot;, d3.forceLink().distance(3).strength(0.5).iterations(2).id(function(d) { return d.id; }))
          .force(&quot;charge&quot;, d3.forceManyBody().strength(-1))
          .force(&quot;center&quot;, d3.forceCenter(width / 2, height / 2));

      simulation
        .nodes(graph.nodes)
        .on(&quot;tick&quot;, ticked);

      simulation.force(&quot;link&quot;)
        .links(graph.links);

      d3.select(canvas)
        .call(d3.drag()
          .container(canvas)
            .subject(dragsubject)
            .on(&quot;start&quot;, dragstarted)
            .on(&quot;drag&quot;, dragged)
            .on(&quot;end&quot;, dragended));

      function ticked() {
        context.clearRect(0, 0, width, height);

        context.beginPath();
        graph.links.forEach(drawLink);
        context.strokeStyle = &quot;#343&quot;;
        context.fillStyle = &quot;#363&quot;;
        context.stroke();

        context.beginPath();
        graph.nodes.forEach(drawNode);
        context.fill();
      }

      function dragsubject() {
        return simulation.find(d3.event.x, d3.event.y);
      }

      function dragstarted() {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d3.event.subject.fx = d3.event.subject.x;
          d3.event.subject.fy = d3.event.subject.y;
      }

      function dragged() {
          d3.event.subject.fx = d3.event.x;
          d3.event.subject.fy = d3.event.y;
      }

      function dragended() {
          if (!d3.event.active) simulation.alphaTarget(0);
          d3.event.subject.fx = null;
          d3.event.subject.fy = null;
      }

      function drawLink(d) {
          context.moveTo(d.source.x, d.source.y);
          context.lineTo(d.target.x, d.target.y);
      }

      function drawNode(d) {
          context.moveTo(d.x + 3, d.y);
          context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
      }

    })();
  &lt;/script&gt;

  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">So we know L-Systems are fun. What if we let d3-force layout the nodes of the L-System?</summary></entry><entry><title type="html">Data binding and JS frameworks</title><link href="https://bitworking.org/news/2017/07/data-binding-and-js-frameworks" rel="alternate" type="text/html" title="Data binding and JS frameworks" /><published>2017-07-16T00:00:00-04:00</published><updated>2017-07-16T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/data-binding-and-js-frameworks</id><content type="html" xml:base="https://bitworking.org/news/2017/07/data-binding-and-js-frameworks">&lt;p&gt;It was over three years ago that I wrote
&lt;a href=&quot;https://bitworking.org/news/2014/05/zero_framework_manifesto&quot;&gt;No more JS frameworks&lt;/a&gt;, at which time
I was roundly criticized for not understanding that data binding could only be
done via JS framework, the two were inextricably linked, and only 2-way data
binding would do, as one way data binding was for weak-minded fools who
weren’t building real applications. You can find the comments on HN yourself,
I don’t link to that cesspool.&lt;/p&gt;

&lt;p&gt;So, in that context, it was funny to read
&lt;a href=&quot;https://medium.com/@chriscordle/why-angular-2-4-is-too-little-too-late-ea86d7fa0bae&quot;&gt;Why Angular 2/4 Is Too Little, Too Late&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Two way data-binding was a feature in 2013 and Facebook said it was a &lt;strong&gt;bug&lt;/strong&gt;.
It turns out they were &lt;em&gt;right&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The post goes on to explain how the “industry settled on
&lt;a href=&quot;http://redux.js.org/&quot;&gt;Redux&lt;/a&gt;”, which is nice to see that the functionality
is delivered as a standalone library, and &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/LICENSE.md&quot;&gt;MIT Licensed&lt;/a&gt;,
because &lt;a href=&quot;https://issues.apache.org/jira/browse/LEGAL-303&quot;&gt;licenses matter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My only concern is that I believe I too work in the industry and I’ve spent
the last three years delivering applications using
&lt;a href=&quot;https://www.polymer-project.org/&quot;&gt;Polymer&lt;/a&gt;, so I guess I’m not “settled”?&lt;/p&gt;</content><author><name></name></author><summary type="html">It was over three years ago that I wrote No more JS frameworks, at which time I was roundly criticized for not understanding that data binding could only be done via JS framework, the two were inextricably linked, and only 2-way data binding would do, as one way data binding was for weak-minded fools who weren’t building real applications. You can find the comments on HN yourself, I don’t link to that cesspool.</summary></entry><entry><title type="html">Tile Store</title><link href="https://bitworking.org/news/2017/07/tile-store" rel="alternate" type="text/html" title="Tile Store" /><published>2017-07-08T00:00:00-04:00</published><updated>2017-07-08T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/tile-store</id><content type="html" xml:base="https://bitworking.org/news/2017/07/tile-store">&lt;p&gt;My team at Google is the infrastructure team for &lt;a href=&quot;https://skia.org&quot;&gt;Skia&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Skia is an open source 2D graphics library which provides common APIs that work
across a variety of hardware and software platforms. It serves as the graphics
engine for Google Chrome and Chrome OS, Android, Mozilla Firefox and Firefox
OS, and many other products.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Skia, being a graphics library, needs to be tested for both performance and
correctness, and being cross-platform, it needs to be tested across a wide
variety of platforms and under different configurations. Skia has a variety of
backends, i.e. the same drawing commands can be directed to be rendered via:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Raster - Using the CPU-only.&lt;/li&gt;
  &lt;li&gt;Ganesh - Skia’s GPU-accelerated backend.&lt;/li&gt;
  &lt;li&gt;PDF - PDF document creation.&lt;/li&gt;
  &lt;li&gt;SVG - An experimental SVG renderer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of those backends need to be tested across different platforms (Windows,
Android, Linux, Max, iOS), different architectures (x86_64, Arm64, Arm7), and a
wide range of other options that can be selected on how Skia renders. Testing a
wide range of GPUs is required because different GPUs have different behaviors,
including some very buggy but widely deployed versions of OpenGL, so we current
test against a large number of both desktop and mobile GPUs. All of this
variety creates a combinatorial explosion in test data. For every commit to
Skia the tests result in roughly 800,000 performance metrics and one million
images being rendered. There are about 30 commits a day to the Skia repo, so
that ends up being a lot of data. Sure, not a lot compared to other projects in
Google, but Skia is open source, and we prefer to build all of our tooling also
as open source, and we needed to build tools to analyze and monitor all those
performance metrics and correctness images, and so we needed data storage with
the following requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Not an SQL database.&lt;/li&gt;
  &lt;li&gt;Very fast access for recent data to allow ad-hoc analysis.&lt;/li&gt;
  &lt;li&gt;Reasonable access for older data.&lt;/li&gt;
  &lt;li&gt;Commit based organization.&lt;/li&gt;
  &lt;li&gt;Robust, i.e. we can’t lose data.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The requirement that it not be an SQL database is a personal preference, I’m
sure there are a large contingent of people that will tell me that Postgres is
the perfect solution, but apparently I’m not smart enough to run/use/tune an
SQL database, particularly for large amounts of data. I might give &lt;a href=&quot;https://cloud.google.com/spanner/&quot;&gt;Spanner&lt;/a&gt; a
chance  in the future, and if so I will certainly give an update. &lt;a href=&quot;https://cloud.google.com/bigquery/&quot;&gt;BigQuery&lt;/a&gt;
might also work. Regardless, we built these apps a long time before either
Spanner or BigQuery were available, so they weren’t viable options at the time.&lt;/p&gt;

&lt;p&gt;One of the other odd requirements is the commit based organization of the data.
This is obviously because the data needs to align with the commits to Skia, but
it isn’t that straightforward because tests on different machines take
different amounts of time, and we also continually backfill tests when we have
spare capacity, so test results almost never arrive in order.&lt;/p&gt;

&lt;p&gt;Since there wasn’t a single system that could meet all these requirements we
split the problem into two systems, one for robust storage, and a second system
for fast access for real time analysis.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Robust storage (GCS) - The ‘source of truth’ documents are stored in Google Cloud Storage.&lt;/li&gt;
  &lt;li&gt;Fast Access (Tile Store) - An intermediate form, built on key-value stores, such as BoltDB, organized into chunks of commits called tiles.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Storing the source of truth documents on Google Cloud Storage takes care of the
robustness. The data files are all JSON and PNG images, which is what is
emitted by the tools that do the performance and correctness testing. The JSON
files are written out to a unique name which include year/month/day/hour in the
path. This allows for easy rebuilding of the Tile Store, just scan for all the
files based on the year/month/day/hour over your desired time range and ingest
them into the Tile Store. And given that the Tile Store can be rebuilt easily
from the ‘source of truth’ documents, we don’t need to back them up.&lt;/p&gt;

&lt;p&gt;The Tile Store is optimized for very fast writes and fast querying.
Additionally, we run on machines large enough to keep all the data for the last
100 commits in memory for very fast access, refreshed from the tiles
periodically.&lt;/p&gt;

&lt;p&gt;For trace data we store each point as a pair, the index of the point and then
the value of the trace at that point. That is, if the tile size is 50 then each
point in a trace is at an index in [0, 49]. So the values stored for a trace
might look like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[0, 1.23], [1, 3.21], [2, 5.67], ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note that the points may not arrive in order, so they could actually be stored
as:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2, 5.67], [0, 1.23], [1, 3.21], ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Also note that points are only appended, and the last value for a point is the
one that’s used, so duplicate data may exist in the trace:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2, 5.67], [0, 1.23], [1, 3.21], [2, 5.50], ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This can happen if a test is re-run, we always use the latter value, so the
value at index 2 of this trace will be 5.50, not 5.67.&lt;/p&gt;

&lt;p&gt;You can check out the &lt;a href=&quot;https://godoc.org/go.skia.org/infra/perf/go/ptracestore&quot;&gt;code and documentation&lt;/a&gt; if you are interested in the
details of the how the tiles are structured.&lt;/p&gt;

&lt;p&gt;I wrote this up mostly as a historical marker, since by next year we might be
fully on Spanner or some other storage technology, and also to find out how
other people have solved similar problems.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;: I just recently came across this talk
&lt;a href=&quot;https://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;Turning the database inside-out with Apache Samza&lt;/a&gt;,
and realized this is very similar, i.e. we use Google Cloud Storage as our
streaming log, and the Tile Store is our Materialized View.&lt;/p&gt;</content><author><name></name></author><summary type="html">My team at Google is the infrastructure team for Skia:</summary></entry><entry><title type="html">L-Systems</title><link href="https://bitworking.org/news/2017/07/l-systems" rel="alternate" type="text/html" title="L-Systems" /><published>2017-07-02T00:00:00-04:00</published><updated>2017-07-02T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/07/l-systems</id><content type="html" xml:base="https://bitworking.org/news/2017/07/l-systems">&lt;p&gt;
  &lt;a href=&quot;https://en.wikipedia.org/wiki/L-system&quot;&gt;L-Systems&lt;/a&gt; are cool. The amount of complexity, and
  naturalness of the forms you can get from such a tiny amount of code is
  amazing.
&lt;/p&gt;
  &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;
    canvas {
    }
  &lt;/style&gt;

  &lt;canvas id=canvas width=400 height=600&gt;&lt;/canvas&gt;
  &lt;script id=src type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    (function () {
      var a = document.getElementById('canvas');
      var c = a.getContext(&quot;2d&quot;);
      function E(s) { return s ? (rules[s[0]] + E(s.substr(1))) : &quot;&quot; }
      M = Math
      r = M.random
      rules = {
        X: &quot;F-[[X]+X]+F[+FX]-X&quot;,
        F: &quot;FF&quot;,
        &quot;+&quot;: &quot;+&quot;,
        &quot;-&quot;: &quot;-&quot;,
        &quot;[&quot;: &quot;[&quot;,
        &quot;]&quot;: &quot;]&quot;,
      }
      L = E(E(E(E(E(&quot;X&quot;)))))
      ys = []
      function draw(x, y, len) {
        p = { x: x, y: y, a: 3 }
        st = []
        c.beginPath()
        c.moveTo(p.x, p.y)
        L.split(&quot;&quot;).forEach(function(ch) {
          if (ch == &quot;F&quot;) {
            p.x += len*M.sin(p.a)
            p.y += len*M.cos(p.a)
            c.lineTo(p.x, p.y)
            c.stroke()
          } else if (ch == &quot;-&quot;) {
            p.a += r()/2
          } else if (ch == &quot;+&quot;) {
            p.a -= r()/2
          } else if (ch == &quot;[&quot;) {
            st.push(JSON.parse(JSON.stringify(p)))
          } else if (ch == &quot;]&quot;) {
            p = st.pop()
            c.beginPath()
            c.moveTo(p.x, p.y)
          }
        })
      }
      for (i = 0; i &lt; a.height/2; i++) {
        ys.push(1-Math.sin(r()*Math.PI/2));
      }
      ys.sort(function(a, b) {return a-b});
      oneStep = function() {
        var v = ys.shift();
        if (v) {
          cl = 0|(1-v)*255
          c.strokeStyle = &quot;rgb(&quot;+[cl,cl,cl]+&quot;)&quot;
          draw(r()*(a.width+100)-50, v*(a.height+100), v*3+0.1)
        }
        window.setTimeout(oneStep, 1);
      }
      window.setTimeout(oneStep, 1);
    })();
  &lt;/script&gt;
  &lt;p&gt;
    The code is intentionally compact as I was intending to submit something
    along these lines to a &lt;a
      href=&quot;https://en.wikipedia.org/wiki/Code_golf&quot;&gt;code golf&lt;/a&gt;
    competition, but then got distracted.
  &lt;/p&gt;
  &lt;pre&gt;&lt;code id=code&gt;&lt;/code&gt;&lt;/pre&gt;
  &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;
    document.getElementById('code').textContent = document.getElementById('src').textContent;
  &lt;/script&gt;</content><author><name></name></author><summary type="html">L-Systems are cool. The amount of complexity, and naturalness of the forms you can get from such a tiny amount of code is amazing.</summary></entry><entry><title type="html">Compute and Moore’s Law</title><link href="https://bitworking.org/news/2017/06/compute-and-moores-law" rel="alternate" type="text/html" title="Compute and Moore's Law" /><published>2017-06-21T00:00:00-04:00</published><updated>2017-06-21T00:00:00-04:00</updated><id>https://bitworking.org/news/2017/06/compute-and-moores-law</id><content type="html" xml:base="https://bitworking.org/news/2017/06/compute-and-moores-law">&lt;p&gt;This article from Technology Review,
&lt;a href=&quot;https://www.technologyreview.com/s/607917/how-ai-can-keep-accelerating-after-moores-law/&quot;&gt;How AI Can Keep Accelerating After Moore’s Law&lt;/a&gt;
is a good follow-on from a previous article
&lt;a href=&quot;https://www.technologyreview.com/s/601441/moores-law-is-dead-now-what/&quot;&gt;Moore’s Law Is Dead. Now What?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;From the second article:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Engineers have kept GPUs getting more powerful because they can be more
specialized to the particular math they need to perform for graphics or
machine learning, he says.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In order to continue to squeeze more performance out of the same number of
transistors and/or watts, we are going to need to get closer to the metal, and
the metal is going to have to become more and more specialized, or at the very
least, the metal has to stop looking like monolithic CPUs with a small number
of cores.&lt;/p&gt;

&lt;p&gt;GPUs by themselves, even if you only have OpenGL, are attractive because
of the enormous amount of specialized computational power available. This power is what
originally attracted people to General Purpose GPU
&lt;a href=&quot;https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units&quot;&gt;GPGPU&lt;/a&gt;, which started as
people transforming scientific computations into a graphical form to get them
to run on a GPU. That work in turn drove the creation and adoption of general
compute APIs like CUDA and then OpenCL, which expose the underlying compute
units and specialized memory access features in a GPU.&lt;/p&gt;

&lt;p&gt;Compute APIs are much closer to the metal, exposing the underlying power of
the GPU without the intervening machinery and bugs of the OpenGL abstraction.
The API surface of these compute APIs are much smaller, which should mean
simpler and less buggy drivers. In addition the compute APIs are focused in
part on scientific applications, so the results from using compute APIs should
be much more repeatable. At the very least using compute APIs we are &lt;a href=&quot;https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/log.html&quot;&gt;in
control of what performance/accuracy tradeoff to make&lt;/a&gt;. Compute APIs are also
becoming more widely available, with every next generation API (Vulkan, DX12,
and Metal) supporting a compute component.&lt;/p&gt;

&lt;p&gt;One of the more surprising things I learned recently was exactly how sloppy
OpenGL could be. For example, from the &lt;a href=&quot;https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/log.html&quot;&gt;documentation for the OpenCL log
function&lt;/a&gt;,
you can choose between the native hardware accelerated version
of log, or use a log function that will return accurate results.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;native_log computes natural logarithm over an implementation-defined range. &lt;strong&gt;The maximum error is implementation-defined&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think it’s time for me to find an OpenCL library for &lt;a href=&quot;https://golang.org&quot;&gt;Go&lt;/a&gt; and
start exploring &lt;a href=&quot;https://cloud.google.com/gpu/&quot;&gt;GPU’s on Google Compute Engine&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">This article from Technology Review, How AI Can Keep Accelerating After Moore’s Law is a good follow-on from a previous article Moore’s Law Is Dead. Now What?.</summary></entry></feed>